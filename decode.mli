(* Batch-mode NES emulator  *)
(* MIT License              *)
(* Ilya Neganov, 2023       *)

type opcode = ADC (* add with carry                   *)
            | AND (* and (with accumulator)           *)
            | ASL (* arithmetic shift left            *)
            | BCC (* branch on carry clear            *)
            | BCS (* branch on carry set              *)
            | BEQ (* branch on equal (zero set)       *)
            | BIT (* bit test                         *)
            | BMI (* branch on minus (negative set)   *)
            | BNE (* branch on not equal (zero clear) *)
            | BPL (* branch on plus (negative clear)  *)
            | BRK (* break / interrupt                *)
            | BVC (* branch on overflow clear         *)
            | BVS (* branch on overflow set           *)
            | CLC (* clear carry                      *)
            | CLD (* clear decimal                    *)
            | CLI (* clear interrupt disable          *)
            | CLV (* clear overflow                   *)
            | CMP (* compare (with accumulator)       *)
            | CPX (* compare with X                   *)
            | CPY (* compare with Y                   *)
            | DEC (* decrement                        *)
            | DEX (* decrement X                      *)
            | DEY (* decrement Y                      *)
            | EOR (* exclusive or (with accumulator)  *)
            | INC (* increment                        *)
            | INX (* increment X                      *)
            | INY (* increment Y                      *)
            | JMP (* jump                             *)
            | JSR (* jump subroutine                  *)
            | LDA (* load accumulator                 *)
            | LDX (* load X                           *)
            | LDY (* load Y                           *)
            | LSR (* logical shift right              *)
            | NOP (* no operation                     *)
            | ORA (* or with accumulator              *)
            | PHA (* push accumulator                 *)
            | PHP (* push processor status (SR)       *)
            | PLA (* pull accumulator                 *)
            | PLP (* pull processor status (SR)       *)
            | ROL (* rotate left                      *)
            | ROR (* rotate right                     *)
            | RTI (* return from interrupt            *)
            | RTS (* return from subroutine           *)
            | SBC (* subtract with carry              *)
            | SEC (* set carry                        *)
            | SED (* set decimal                      *)
            | SEI (* set interrupt disable            *)
            | STA (* store accumulator                *)
            | STX (* store X                          *)
            | STY (* store Y                          *)
            | TAX (* transfer accumulator to X        *)
            | TAY (* transfer accumulator to Y        *)
            | TSX (* transfer stack pointer to X      *)
            | TXA (* transfer X to accumulator        *)
            | TXS (* transfer X to stack pointer      *)
            | TYA (* transfer Y to accumulator        *)
            | ILL (* Illegal                          *)

type addr_mode = Accum    (* OPC A       | operand is AC (implied single byte instruction)                                                                    *)
               | Abs      (* OPC $LLHH   | operand is address $HHLL *                                                                                         *)
               | Abs_X    (* OPC $LLHH,X | operand is address; effective address is address incremented by X with carry **                                    *)
               | Abs_Y    (* OPC $LLHH,Y | operand is address; effective address is address incremented by Y with carry **                                    *)
               | Immed    (* OPC #$BB    | operand is byte                                                                                                    *)
               | Implied  (* OPC         | operand implied                                                                                                    *)
               | Ind      (* OPC ($LLHH) | operand is address; effective address is contents of word at address: C.w($HHLL)                                   *)
               | X_Ind    (* OPC ($LL,X) | operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X) *)
               | Ind_Y    (* OPC ($LL),Y | operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y *)
               | Rel      (* OPC $BB     | branch target is PC + signed offset BB ***                                                                         *)
               | Zpg      (* OPC $LL     | operand is zeropage address (hi-byte is zero, address = $00LL)                                                     *)
               | Zpg_X    (* $LL,X       | operand is zeropage address; effective address is address incremented by X without carry **                        *)
               | Zpg_Y    (* OPC $LL,Y   | operand is zeropage address; effective address is address incremented by Y without carry **                        *)

type inst_size = SZ_1 | SZ_2 | SZ_3

type instn = Instr of opcode * addr_mode * inst_size * int

val decode           : int -> instn
val show_opcode      : opcode -> string
val show_instn       : instn  -> string
val show_full_instn  : instn -> int -> int -> string
val isize_incr       : inst_size -> int
val is_not_store     : opcode -> bool
